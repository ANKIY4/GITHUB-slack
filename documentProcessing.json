{
  "nodes": [
    {
      "parameters": {
        "resource": "fileFolder",
        "searchMethod": "query",
        "queryString": "='1WefIo4Is3XDkcsRIYqmJ6R_q56Qe1X_7' in parents and mimeType = 'application/vnd.google-apps.folder'",
        "returnAll": true,
        "filter": {},
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -2768,
        240
      ],
      "id": "67b64eb9-cc9c-4299-a9ce-5af1f108d22a",
      "name": "Get folders1",
      "executeOnce": true,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "nPvIl6a0PUeHoEsL",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "resource": "fileFolder",
        "searchMethod": "query",
        "queryString": "='{{ $json.id }}' in parents and mimeType = 'application/pdf'",
        "returnAll": true,
        "filter": {},
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -2544,
        240
      ],
      "id": "f2ff3c31-3f45-4a96-a1eb-2c0bc4813c94",
      "name": "get documents1",
      "executeOnce": false,
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "nPvIl6a0PUeHoEsL",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "function cleanText(str) {\n  if (typeof str !== 'string') return '';\n\n  return str\n    // Remove long separator lines (dashes, underscores, equals, etc.)\n    .replace(/[-_=]{3,}/g, ' ')\n    // Remove repeated dots or ellipsis (ASCII and Unicode)\n    .replace(/[\\.\\u2026\\u00B7]{2,}/g, ' ')\n    // Remove unnecessary brackets\n    .replace(/[\\(\\)\\[\\]\\{\\}]/g, ' ')\n    // Remove other repeated symbols (like •, ·, ‧)\n    .replace(/[\\u2022\\u00B7\\u2027]{2,}/g, ' ')\n    // Remove all line breaks, carriage returns, tabs\n    .replace(/[\\r\\n\\t]+/g, ' ')\n    // Replace any sequence of whitespace (including Unicode) with a single space\n    .replace(/\\s+/gu, ' ')\n    // Trim leading/trailing spaces\n    .trim();\n}\n\nconst chunkSize = 1500; // words per chunk\nlet output = [];\n\nitems.forEach((item, itemIndex) => {\n  const rawContent = item?.json?.text || '';\n  const cleanedContent = cleanText(rawContent);\n\n  // If no content after cleaning, still return a single \"final\" empty chunk\n  if (!cleanedContent) {\n    output.push({\n      json: {\n        chunk: '',\n        chunkIndex: 1,\n        totalChunks: 1,\n        chunkStatus: 'final',\n        sourceItem: itemIndex + 1\n      }\n    });\n    return;\n  }\n\n  const words = cleanedContent.split(/\\s+/);\n  const totalChunks = Math.ceil(words.length / chunkSize);\n  let chunk = [];\n\n  for (let i = 0; i < words.length; i++) {\n    chunk.push(words[i]);\n\n    if (chunk.length >= chunkSize || i === words.length - 1) {\n      const chunkIndex = output.length + 1;\n      output.push({\n        json: {\n          chunk: chunk.join(' '),\n          chunkIndex,\n          totalChunks,\n          chunkStatus: chunkIndex === totalChunks ? 'final' : 'more',\n          sourceItem: itemIndex + 1 // useful if processing multiple items\n        }\n      });\n      chunk = [];\n    }\n  }\n});\n\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -848,
        128
      ],
      "id": "fd11af4c-a211-48f6-ba01-9c798460ff7b",
      "name": "CleanText"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4",
          "mode": "list",
          "cachedResultName": "gpt-4"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -2176,
        432
      ],
      "id": "58c09bfa-3f72-40ff-9421-becea5b9a070",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "f55YpwofdI64MQ90",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "ca70ecb2-2bd1-45bb-abc8-9a96724f23d5",
              "leftValue": "={{ $json.found }}",
              "rightValue": "success",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1504,
        240
      ],
      "id": "5a817c53-764f-415e-90a0-f062ab84b7c4",
      "name": "If1"
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "select": "channel",
        "channelId": {
          "__rl": true,
          "value": "C097PV4TDL1",
          "mode": "list",
          "cachedResultName": "all-automartion-ai-crumb"
        },
        "text": "={{ $json.message }}",
        "otherOptions": {}
      },
      "type": "n8n-nodes-base.slack",
      "typeVersion": 2.3,
      "position": [
        -1232,
        448
      ],
      "id": "e17a98f9-9594-44e6-804c-79c509b88b5c",
      "name": "Slack",
      "webhookId": "044ecd88-7818-4853-9755-3dae9040feec",
      "disabled": true
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -528,
        352
      ],
      "id": "31f41026-cb21-423a-acea-7019bfde2709",
      "name": "OpenAI Chat Model2",
      "credentials": {
        "openAiApi": {
          "id": "f55YpwofdI64MQ90",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "c75f4dd9-94e8-481b-8c85-db1d82957c05",
              "leftValue": "={{ $json.status }}",
              "rightValue": "success",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        192,
        288
      ],
      "id": "2de46cb1-ea78-40c9-890a-c4b10e1b9c97",
      "name": "If2"
    },
    {
      "parameters": {
        "jsCode": "return{\n  json:{\n    output: \" the specific information you are looking for was not found in the document\"\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -144
      ],
      "id": "22fec69d-72ee-4deb-b702-878d0d41d995",
      "name": "Code6"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -624,
        32
      ],
      "id": "7dc36529-2e98-4df7-ba98-6ca4ef7fb5ae",
      "name": "Loop Over each chunk"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=CHUNK STATUS:\n{{ $json.chunkStatus }}\n\nUSER MESSAGE:\n{{ $('FORMAT THE FILES INPUT').item.json.userMsg }}\n\nCHUNK TEXT DATA:\n{{ $json.chunk }}",
        "options": {
          "systemMessage": "=You are an AI document chunk analysis engine.\n\nYour task:\nYou will receive:\n1. CHUNK STATUS: {{ $json.chunkStatus }}\n2. USER MESSAGE: {{ $('FORMAT THE FILES INPUT').item.json.userMsg }}\n3. CHUNK TEXT DATA: {{ $json.chunk }}\n\nInstructions:\n- The USER MESSAGE may contain part of the file name. Ignore that and focus ONLY on the real question being asked.\n- Read every word of the CHUNK TEXT DATA carefully.\n- Your goal is to determine if the chunk contains a **clear, direct, and factually correct** answer to the user’s question — without assumptions or guessing.\n- A satisfactory answer must be:\n  * Directly supported by the text in the chunk.\n  * Explicitly relevant to the exact question asked.\n  * Complete enough to stand alone without requiring missing context from other chunks.\n\nDecision Rules:\n1. **If the chunk contains a clear, relevant, and complete answer:**\n   - Stop immediately.\n   - Return:\n   {\n     \"status\": \"success\",\n     \"message\": \"<draft answer that directly addresses the user's question using only information from the chunk>\"\n   }\n\n2. **If the chunk does NOT contain a clear and complete answer:**\n   - Return:\n   {\n     \"status\": \"processed\",\n     \"message\": \"<short draft message, note, or empty string if nothing useful>\"\n   }\n   - The system will then check other chunks.\n\n3. **If CHUNK STATUS is \"final\" and no satisfactory answer was found in any chunk:**\n   - Return:\n   {\n     \"status\": \"failed\",\n     \"message\": \"<a polite message stating the answer was not found>\"\n   }\n\nStrict Rules:\n- NEVER guess or invent details.\n- NEVER combine partial answers from different chunks — success is only triggered if the answer in this chunk alone is enough.\n- Respond ONLY with valid JSON. No explanations, no markdown, no extra text.\n- The JSON must exactly match one of the formats above or the system will break.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        -400,
        160
      ],
      "id": "3da38e53-1e92-4bf2-86a5-50371b3db716",
      "name": "process the chunk"
    },
    {
      "parameters": {
        "jsCode": "let outputStr = items[0].json.output;\n\n// Remove markdown-style backticks or code fences\noutputStr = outputStr\n  .trim()\n  .replace(/^```json\\s*/i, '')   // Remove ```json if it starts the string\n  .replace(/^```\\s*/i, '')       // Or plain ``` without language tag\n  .replace(/```$/i, '');         // Remove closing ```\n\nlet parsedOutput;\ntry {\n  parsedOutput = JSON.parse(outputStr);\n} catch (err) {\n  throw new Error(\"Failed to parse cleaned JSON: \" + err.message);\n}\n\nreturn [\n  {\n    json: parsedOutput\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        176
      ],
      "id": "34013bb7-6f6f-4421-9753-4347a9ae1e04",
      "name": "FORMAT THE OUTPUT IN JSON"
    },
    {
      "parameters": {
        "jsCode": "return[{\n  json:{\n    output: $input.all().map(item => item.json),\n    userMsg:$('When Executed by Another Workflow').first().json.query\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2320,
        240
      ],
      "id": "e95623ed-8038-498d-ae11-515b9f6ba963",
      "name": "FORMAT THE FILES INPUT"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      output: $input.first().json.message\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        288
      ],
      "id": "25da9ced-68f8-4e9c-9ee8-f48232eea561",
      "name": "Code4"
    },
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -2976,
        240
      ],
      "id": "f1a32d56-5dcf-413e-ae91-8b666997afc2",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "jsCode": "let outputStr = items[0].json.output;\n\n// Remove markdown-style backticks or code fences\noutputStr = outputStr\n  .trim()\n  .replace(/^```json\\s*/i, '')   // Remove ```json if it starts the string\n  .replace(/^```\\s*/i, '')       // Or plain ``` without language tag\n  .replace(/```$/i, '');         // Remove closing ```\n\nlet parsedOutput;\ntry {\n  parsedOutput = JSON.parse(outputStr);\n} catch (err) {\n  throw new Error(\"Failed to parse cleaned JSON: \" + err.message);\n}\n\nreturn [\n  {\n    json: parsedOutput\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1728,
        240
      ],
      "id": "5a5bb7e3-8a93-4b94-af44-b242f8236c1a",
      "name": "PARSE THE INPUT IN JSON"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=THE USER MESSAGE:\n{{ $json.userMsg }}\n\nALL THE FILES WITH NAME AND ID:\n{{ JSON.stringify($json.output, null, 2) }}",
        "options": {
          "systemMessage": "=You are an AI file name matching engine. Your ONLY task is to identify which file from a provided list the user is referring to.\n\nInputs you will receive:\n1. USER MESSAGE: the message from the user\n2. ALL FILES WITH NAME AND ID: an array of files containing id and the name of the google docs file.\n\nRules:\n- The user message may contain the exact file name, a partial file name, or just hints/keywords from the file name.\n- You must identify the single best matching file from the list, even if the match is partial or approximate.\n- Always match robustly: tolerate spelling variations, partial words, and reordered terms.\n- If there are multiple possible matches, select the one that is most specific to the user's message.\n- Do NOT guess outside of the provided file list. If none of the files match, respond with the \"failed\" JSON.\n\nResponse format:\n- If a matching file is found:\n{\n  \"found\": \"success\",\n  \"id\": \"<the id of the file>\",\n  \"name\": \"<the name of the file>\"\n}\n\n- If no matching file is found:\n{\n  \"found\": \"failed\",\n  \"message\": \"the resources cant be found to give the answer to this question!\"\n}\n\nSTRICT REQUIREMENTS:\n- Respond ONLY in JSON.\n- No explanations, no additional text, no markdown formatting.\n- Your output must be valid JSON that can be parsed directly.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.9,
      "position": [
        -2096,
        240
      ],
      "id": "4315f95b-4600-40de-b3dd-07b6e6297892",
      "name": "Filter docs"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.chunk }}",
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -304,
        336
      ],
      "id": "56ac002f-dfa4-40c0-a79e-905a542a94eb",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.id }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -1280,
        128
      ],
      "id": "05c77d75-5d58-4383-928a-1876f8c71647",
      "name": "Google Drive",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "nPvIl6a0PUeHoEsL",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -1072,
        128
      ],
      "id": "94541d08-4f1c-4206-a762-58776d56c172",
      "name": "Extract from File"
    }
  ],
  "connections": {
    "Get folders1": {
      "main": [
        [
          {
            "node": "get documents1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "get documents1": {
      "main": [
        [
          {
            "node": "FORMAT THE FILES INPUT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CleanText": {
      "main": [
        [
          {
            "node": "Loop Over each chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Filter docs",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Google Drive",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "process the chunk",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "If2": {
      "main": [
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "CleanText",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over each chunk": {
      "main": [
        [
          {
            "node": "Code6",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "process the chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process the chunk": {
      "main": [
        [
          {
            "node": "FORMAT THE OUTPUT IN JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FORMAT THE OUTPUT IN JSON": {
      "main": [
        [
          {
            "node": "If2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FORMAT THE FILES INPUT": {
      "main": [
        [
          {
            "node": "Filter docs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When Executed by Another Workflow": {
      "main": [
        [
          {
            "node": "Get folders1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PARSE THE INPUT IN JSON": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter docs": {
      "main": [
        [
          {
            "node": "PARSE THE INPUT IN JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "process the chunk",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Google Drive": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "CleanText",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {
    "When Executed by Another Workflow": [
      {
        "query": "senior deveoper contract"
      }
    ]
  },
  "meta": {
    "instanceId": "0aa722f86bb332e232ec98ea168cef818ddee9aedd3b741e78182c3ab3631ee1"
  }
}
